<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>공간:결 - 서랍 관리</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="style.css">
</head>
<body>
<div id="loadingOverlay" class="loading-overlay">
  <div class="spinner"></div>
  <p class="loading-text">비서 <b>'결'</b>이 확인 중입니다...</p>
</div>

<div class="container">
  <div class="header" style="margin-top: 20px;">
    <h1 id="drawer-title" style="margin:0; font-size: 1.8rem;">서랍</h1>
    <button class="btn-add" onclick="document.getElementById('fileInput').click()">+</button>
    <input type="file" id="fileInput" hidden accept="image/*,video/*" onchange="processFile(this.files[0])">
  </div>

  <div class="card">
    <input type="text" id="drawer-search" class="search-box" style="margin-bottom:20px;" placeholder="이 서랍에서 검색">
    <div id="item-list">
      <p style="text-align:center; color:#888; padding: 40px 0;">등록된 물건이 없습니다.<br>사진을 찍어 등록해 보세요.</p>
    </div>
  </div>
</div>

<script>
const urlParams = new URLSearchParams(window.location.search);
const tag = urlParams.get('tag') || 'DRAWER001';
document.getElementById('drawer-title').innerText = tag;

// [해결사] 사진 자동 압축 로직 (Vercel 용량 제한 돌파) [cite: 2026-02-23]
async function compressImage(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = (e) => {
      const img = new Image();
      img.src = e.target.result;
      img.onload = () => {
        const canvas = document.createElement('canvas');
        let width = img.width; let height = img.height;
        const MAX = 1200; // 최대 크기 제한으로 용량 대폭 축소
        if (width > height) { if (width > MAX) { height *= MAX / width; width = MAX; } }
        else { if (height > MAX) { width *= MAX / height; height = MAX; } }
        canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        canvas.toBlob((blob) => {
          resolve(new File([blob], file.name, { type: 'image/jpeg' }));
        }, 'image/jpeg', 0.7); // 품질 70%로 압축
      };
    };
  });
}

async function processFile(file) {
  if (!file) return;
  document.getElementById('loadingOverlay').style.display = 'flex';

  try {
    let fileToSend = file;
    // 이미지면 무조건 압축 시도
    if (file.type.startsWith('image/')) {
      fileToSend = await compressImage(file);
    } 
    // 영상이면 용량만 체크 (브라우저 압축 불가)
    else if (file.size > 4.5 * 1024 * 1024) {
      alert("영상은 4.5MB 이하(약 5초)만 가능합니다.");
      document.getElementById('loadingOverlay').style.display = 'none';
      return;
    }

    const formData = new FormData();
    formData.append('file', fileToSend);
    formData.append('tag', tag);

    const resp = await fetch('/api/analyze', { method: 'POST', body: formData });
    const data = await resp.json();

    if (data.error) throw new Error(data.error);
    alert("비서 '결'이 물건을 등록했습니다!");
    location.reload();
  } catch (err) {
    alert("오류: " + err.message);
  } finally {
    document.getElementById('loadingOverlay').style.display = 'none';
  }
}
</script>
</body>
</html>
