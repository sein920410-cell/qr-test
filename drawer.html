<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>공간:결 - 서랍 관리</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="style.css">
</head>
<body>

<div id="loadingOverlay" class="loading-overlay">
  <div class="spinner"></div>
  <p class="loading-text">비서 <b>'결'</b>이 사진을 압축하고 분석 중입니다...</p>
</div>

<div class="container">
  <div class="header" style="margin-top: 20px;">
    <h1 id="drawer-title" style="margin:0;">서랍</h1>
    <button class="btn-add" onclick="document.getElementById('fileInput').click()">+</button>
    <input type="file" id="fileInput" hidden accept="image/*,video/*" onchange="processFile(this.files[0])">
  </div>

  <div class="card">
    <input type="text" id="drawer-search" class="search-box" style="margin-bottom:20px;" placeholder="이 서랍에서 검색">
    <div id="item-list">
      <p style="text-align:center; color:#888;">등록된 물건이 없습니다.</p>
    </div>
  </div>
</div>

<script>
const urlParams = new URLSearchParams(window.location.search);
const tag = urlParams.get('tag') || 'DRAWER001';
document.getElementById('drawer-title').innerText = tag;

// [확실한 해결책] 사진 자동 압축 함수
async function compressImage(file) {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = (event) => {
      const img = new Image();
      img.src = event.target.result;
      img.onload = () => {
        const canvas = document.createElement('canvas');
        let width = img.width;
        let height = img.height;

        // 가로 세로 최대 1280px로 조절 (용량 급감)
        const MAX_SIZE = 1280;
        if (width > height) {
          if (width > MAX_SIZE) { height *= MAX_SIZE / width; width = MAX_SIZE; }
        } else {
          if (height > MAX_SIZE) { width *= MAX_SIZE / height; height = MAX_SIZE; }
        }

        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);

        // 품질을 0.7로 낮추어 용량을 확실히 줄임
        canvas.toBlob((blob) => {
          resolve(new File([blob], file.name, { type: 'image/jpeg' }));
        }, 'image/jpeg', 0.7);
      };
    };
  });
}

async function processFile(file) {
  if (!file) return;
  document.getElementById('loadingOverlay').style.display = 'flex';

  try {
    let fileToSend = file;

    // 1. 이미지라면 자동으로 압축 진행
    if (file.type.startsWith('image/')) {
      fileToSend = await compressImage(file);
    } 
    // 2. 영상이라면 용량 체크만 진행 (영상은 브라우저 압축이 어려움)
    else if (file.size > 4.5 * 1024 * 1024) {
      alert("영상은 4.5MB를 넘을 수 없어요. 5초 이내로 짧게 찍어주세요!");
      document.getElementById('loadingOverlay').style.display = 'none';
      return;
    }

    const formData = new FormData();
    formData.append('file', fileToSend);
    formData.append('tag', tag);

    const resp = await fetch('/api/analyze', { method: 'POST', body: formData });
    const data = await resp.json();

    if (data.error) throw new Error(data.error);
    alert("비서 '결'이 등록을 마쳤습니다!");
    location.reload();
  } catch (err) {
    alert("오류: " + err.message);
  } finally {
    document.getElementById('loadingOverlay').style.display = 'none';
  }
}
</script>
</body>
</html>
